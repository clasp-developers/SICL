(cl:in-package #:cleavir-ast-to-hir)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Compilation context.
;;;
;;; Each AST is compiled in a particular COMPILATION CONTEXT or
;;; CONTEXT for short.  A context object has three components:
;;;
;;; 1. SUCCESSORS, which is a proper list containing zero or two
;;; elements.  These elements are instructions resulting from the
;;; generation of the code that should be executed AFTER the code
;;; generated from this AST.  If the list contains two elements, then
;;; this AST is compiled in a context where a Boolean result is
;;; required.  In this case, the first element of the list is the
;;; successor to use when the value generated by the AST is NIL, and
;;; the second element is the successor to use when the value
;;; generated by the AST is something other than NIL.
;;;
;;; 2. RESULTS, indicating how many values are required from the
;;; compilation of this AST.  It can be either a list or an atom as
;;; describe below.  If it is a list, it contains zero or more lexical
;;; locations into which the generated code must put the values of
;;; this AST.  If the list contains more elements than the number of
;;; values generated by this AST, then the remaining lexical locations
;;; in the list must be filled with NIL by the code generated from
;;; this AST.  If it is an atom then it is a single datum of the type
;;; VALUES-LOCATION, which means that ALL values are required and
;;; should be stored in that location.
;;;
;;; 3. INVOCATION, always an ENTER-INSTRUCTION.  It indicates the
;;; function to which the code to be compiled belongs.
;;;
;;; The following combinations of SUCCESSORS and RESULTS can occur:
;;;
;;;   SUCCESSORS has one element.  then RESULTS can be a list of
;;;   lexical locations or a single values location.
;;;
;;;      If RESULTS is the empty list, this means that no values are
;;;      required.  Forms inside a PROGN other than the last are
;;;      compiled in a context like this.
;;;
;;;      If RESULTS has a single element, then a single value is
;;;      required.  Arguments to function calls are examples of ASTs
;;;      that are compiled in a context like this.
;;;
;;;      If RESULTS has more than one element, then that many values
;;;      are required.  The VALUES-FORM-AST of MULTIPLE-VALUE-BIND-AST
;;;      is compiled in a context like this.
;;;
;;;      If RESULTS is a values location, then all values are
;;;      required.  An example of the use of this context is for
;;;      compiling the FIRST-FORM of a MULTIPLE-VALUE-PROG1 special
;;;      form.
;;;
;;;   SUCCESSOR has two elements.  Then RESULTS is the empty list,
;;;   meaning that no values are required.  The TEST-AST of an IF-AST
;;;   is compiled in a context like this.
;;;
;;;   SUCCESSORS has more than two elements.  This possibility is
;;;   currently not used.  It is meant to be used for forms like CASE,
;;;   TYPECASE, etc.  Again, the RESULTS would be the empty list.

;;; It is highly likely that the slots corresponding to optimize
;;; qualities will disappear in the future, and be replaced by a
;;; different organization.  There are several reasons for this
;;; change:
;;;
;;;  * We think it is difficult to come up with a technique that
;;;    allows the implementation to add its own optimize qualities
;;;    while relying on default treatment of the standard ones.
;;;
;;;  * We think we need a bunch of flags that allow finer control of
;;;    the compilation process, such as controlling whether a variable
;;;    should be kept alive until it is out of scope in the source,
;;;    whether a variable should be available even though the compiler
;;;    can prove that it is constant and so could remove it, etc.
;;;
;;;  * Since there would typically be many more of these compilation
;;;    flags than there are optimize qualities, an initial set of flag
;;;    values would have to be computed from the optimize quality
;;;    values, but then the flag values could evolve independently of
;;;    the optimize.
;;;
;;; A tentative solution to this problem would be to have two objects
;;; in the context; one object that contains the current optimize
;;; qualities and another object that contains current flags.  We
;;; would provide default methods for computing a flag object from an
;;; object containing optimize qualities.  The implementation would be
;;; allowed to created subclasses from both these classes so as to add
;;; new optimize qualities and new flags.  We would provide a
;;; mechanism to customize the computation that would only need to
;;; provide differences from the default.

(defclass context ()
  ((%results :initarg :results :reader results)
   (%successors :initarg :successors :accessor successors)
   (%invocation :initarg :invocation :reader invocation)
   (%speed-value
    :initform 1
    :initarg :speed-value
    :reader speed-value)
   (%debug-value
    :initform 1
    :initarg :debug-value
    :reader debug-value)
   (%safety-value
    :initform 1
    :initarg :safety-value
    :reader safety-value)
   (%space-value
    :initform 1
    :initarg :space-value
    :reader space-value)
   (%compilation-speed-value
    :initform 1
    :initarg :compilation-speed-value
    :reader compilation-speed-value)))

(defun context (results successors invocation)
  (unless (or (and (listp results)
		   (every (lambda (result)
			    (typep result 'cleavir-ir:lexical-location))
			  results))
	      (typep results 'cleavir-ir:values-location))
    (error "illegal results: ~s" results))
  (unless (and (listp successors)
	       (<= 1 (length successors) 2)
	       (every (lambda (successor)
			(typep successor 'cleavir-ir:instruction))
		      successors))
    (error "illegal successors: ~s" successors))
  (when (and (= (length successors) 2) (not (null results)))
    (error "Illegal combination of results and successors"))
  (unless (typep invocation 'cleavir-ir:enter-instruction)
    (error "Illegal invocation"))
  (make-instance 'context
    :results results
    :successors successors
    :invocation invocation))

(defmethod print-object ((obj context) stream)
  (print-unreadable-object (obj stream)
    (format stream " results: ~s" (results obj))
    (format stream " successors: ~s" (successors obj))))

(defun clone-context (context &rest args)
  (apply #'reinitialize-instance
	 (make-instance 'context
			:result (results context)
			:successor (successors context)
			:invocation (invocation context)
			:speed-value (speed-value context)
			:debug-value (debug-value context)
			:safety-value (safety-value context)
			:space-value (space-value context)
			:compilation-speed-value (compilation-speed-value context))
	 args))
