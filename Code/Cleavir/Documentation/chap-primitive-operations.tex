\chapter{Primitive operations}

\section{Purpose}

Primitive operations (or primops for short) are similar to
\commonlisp{} special operators in that the compiler handles them
specially.  They are different from \commonlisp{} special operators in
that a primop does not necessarily have an evaluation rule that is
different from that of a function call.

Generally speaking, primops should not be used directly in application
code.  Instead, they are used in system code for implementing certain
basic \commonlisp{} function.  So, for example, the \texttt{car}
primop would typically be used only in the code for the \commonlisp{}
function \texttt{car}.  That function would then be inlined by the
compiler, so that the resulting AST and ultimately the resulting HIR
instruction that the \texttt{car} primop translates to will be present
also in application code.

Frequently, the need for a primop comes from arises because some HIR
instruction is needed.  Take, for example, the HIR instruction named
\texttt{eq-instruction} for comparing two pointer values for equality.
The existence of that instruction requires an AST doing the same
thing, and it is called \texttt{eq-ast}.  When compiled to HIR, the
\texttt{eq-ast} generates the an \texttt{eq-instruction}.  Finally, in
order to produce the source for the \commonlisp{} function
\texttt{eq}, it must be possible to produce the \texttt{eq-ast} from
some \commonlisp{} code, which is why the \texttt{eq} primop is
needed.

\section{Package}

All primitive operations have names that are symbols in the package
named \texttt{cleavir-primop}.  This package contains only those
symbols that name the primitive operations.  There is no code directly
associated with the primitive operations.  Instead, the code for
translating primitive operations to abstract syntax trees
\seechap{chap-abstract-syntax-tree} is in the form of methods on the
function \texttt{cleavir-generate-ast:convert-special}.

\section{Existing primitive operations}

\def\defprimop #1 {\dodocv {#1} {Primitive operation}}

\defprimop{eq}

This primitive operation has the same semantics as the \commonlisp{}
function \texttt{eq}, except that it can only appear as the
\emph{test-form} in the special form \texttt{if}.  Its main purpose is
for defining the code for that \commonlisp{} function.  Typically the
\commonlisp{} \texttt{eq} function will be declared \texttt{inline} so
that the abstract syntax tree and HIR instruction resulting from this
primop will eventually end up in the compiled code of many
applications.

\defprimop{typeq}

This primitive operation is similar to the \commonlisp{} function
\texttt{typep}.  It differs from the \commonlisp{} function in that it
does not evaluate its second argument, i.e., the type specifier.
Also, it does not take an optional environment argument%
\footnote{We may have to add an environment argument to
  \texttt{typeq}.  Alternatively we may have to specify that it only
  takes certain types that do not depend on the environment.}
like \texttt{typep} does.

The implementation may have a compiler macro on the function
\texttt{typep} so that it turns into \texttt{typeq} when the second
argument is a constant.  The \texttt{typeq} primitive operation can
also be used in the implementation of certain system functions that
need to check for constant types.

The \texttt{typeq} generates a \texttt{typeq} AST and ultimately a
\texttt{typeq} HIR instruction.  This instruction is used by the type
inferencer \seesec{sec-optimizations-type-inference} to infer
different types in different successor branches.

\defprimop{consp}

This primitive operation has the same semantics as the \commonlisp{}
function \texttt{consp}.  Its main purpose is for defining the code
for that \commonlisp{} function.  Typically the \commonlisp{}
\texttt{consp} function will be declared \texttt{inline} so that the
abstract syntax tree and HIR instruction resulting from this primop
will eventually end up in the compiled code of many applications.

\defprimop{car}

This primitive operation is typically used in the implementation of
the \commonlisp{} function \texttt{car}.  The main difference between
this primitive operation and the \commonlisp{} function is that the
primitive operation requires its argument to evaluate to a
\texttt{cons}.  For that reason, if used to implement the
\commonlisp{} function \texttt{car}, this primitive operation should
be preceded by a test (using the primitive operation \texttt{typeq})
to verify that the argument is a \texttt{cons}.  A typical
implementation of the \texttt{car} function might look like this:

\begin{verbatim}
  (defun car (object)
    (if (cleavir-primop:typeq object cons)
        (cleavir-primop:car object)
        (if (cleavir-primop:typeq object null)
            nil
            (error 'type-error
                   :datum object
                   :expected-type '(or cons null)))))
\end{verbatim}

The \commonlisp{} \texttt{car} function will typically be declared
\texttt{inline}, allowing the type inferencer
\seesec{sec-optimizations-type-inference} to use the \texttt{typeq}
primitive operation to remove redundant type checks.

\defprimop{cdr}

This primitive operation is typically used in the implementation of
the \commonlisp{} function \texttt{cdr}.  The main difference between
this primitive operation and the \commonlisp{} function is that the
primitive operation requires its argument to evaluate to a
\texttt{cons}.  For that reason, if used to implement the
\commonlisp{} function \texttt{cdr}, this primitive operation should
be preceded by a test (using the primitive operation \texttt{typeq})
to verify that the argument is a \texttt{cons}.  A typical
implementation of the \texttt{cdr} function might look like this:

\begin{verbatim}
  (defun cdr (object)
    (if (cleavir-primop:typeq object cons)
        (cleavir-primop:cdr object)
        (if (cleavir-primop:typeq object null)
            nil
            (error 'type-error
                   :datum object
                   :expected-type '(or cons null)))))
\end{verbatim}

The \commonlisp{} \texttt{cdr} function will typically be declared
\texttt{inline}, allowing the type inferencer
\seesec{sec-optimizations-type-inference} to use the \texttt{typeq}
primitive operation to remove redundant type checks.
