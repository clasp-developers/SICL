\chapter{Translating AST to HIR}
\label{chap-translating-ast-to-hir}

The translation of an abstract syntax tree
\seechap{chap-abstract-syntax-tree} to high-level intermediate
representation \seechap{chap-ir} is done by an algorithm that is
similar to that of CPS-conversion.%
\footnote{CPS means Continuation Passing Style.}

As with CPS-conversion, translation makes the control structure
explicit.  Another similarity is that translation is done from the end
of the program to the beginning.

\section{\asdf{} system name}

The name of the \asdf{} system that accomplishes the translation of an
abstract syntax tree into HIR is called \texttt{cleavir-ast-to-hir}
and it is located in the file \texttt{cleavir-ast-to-hir.asd} in the
sub-directory named \texttt{AST-to-HIR}.

\section{Package}

The name of the package that contains the names specific to this
system is \texttt{cleavir-ast-to-hir}.  It is defined in the file
named \texttt{packages.lisp} in the sub-directory named
\texttt{AST-to-HIR}.

\section{Compilation context}

Translation of an AST is accomplished with respect to a
\emph{compilation context}.  This context contains a \emph{list of
  lexical variables} to which the values of the translated AST must be
assigned.  The length of the list corresponds to the number of values
required by the context.  The context also contains a \emph{list of
  successors} which represent MIR instructions to which transfer
control after evaluation of the current AST.

\Defclass {context}

This class is the base class for compilation contexts.

\Definitarg {:results}

\Definitarg {:successors}

This argument must be a proper list containing zero, one, or two
elements.  These elements are instructions resulting from the
generation of the code that should be executed \emph{after} the code
generated from this AST.

In most cases, this list contains a single element representing the
instruction to which control should be transferred after the execution
of the code resulting from the compilation of the current AST.

Currently, no AST is compiled in a context with zero successors.

If the list contains two elements, then this AST is compiled in a
context where a Boolean result is required.  In this case, the first
element of the list is the successor to use when the value generated
by the AST is \texttt{nil}, and the second element is the successor to
use when the value generated by the AST is something other than
\texttt{nil}.

The \texttt{test-ast} of an \texttt{if-ast} is an example of an AST
that is compiled in a context with two successors.

\Defun {context} {results successors invocation}

This function is deprecated in favor of the function
\texttt{clone-context}.

This function creates a new context, passing the \textit{results}
argument as the \texttt{:results} initarg, the \textit{successors}
argument as the \texttt{:successors} initarg, and the
\textit{invocation} argument as the \texttt{:invocation} initarg.
All other slots of the new context are initialized according to the
\texttt{:initform} of the slot.

\Defun {clone-context} {context \rest arguments}

This function makes a copy of \textit{context} and then calls
\texttt{reinitialize-instance}, passing it the copy and all the
\textit{arguments}.  Here, \textit{arguments} should contain
alternating keywords and keyword arguments that are acceptable for
re-initializing an instance of the class \texttt{context}.  The net
effect is that \textit{context} is cloned with the exception of the
initialization arguments in \textit{arguments}.

The reason for the existence of this function is that it is possible
to add future slots to the class \texttt{context} without breaking
existing code.  Such slots will simply be copied by existing code.
Another reason is that frequently a new context is only slightly
different from some existing context that is available when the new
context must be created.

The compilation context contains two objects that control the details
of the compilation as described below.%
\footnote{The remaining part of this section describes a preliminary
  design choice.  It has not yet been implemented, and it may change.
  Comments are welcome.}

\Defclass {optimize-qualities}

This class is a container for optimize qualities.  It contains the
optimize qualities defined in the \hs{}.  Implementations may provide
their own optimize qualities by creating a subclass of this class.
Each \texttt{:initarg} for this class must be an integer between $0$ and
$3$ inclusive and specifies the corresponding \emph{value} of the
optimize quality according to the \hs{}.

Instances of this class are immutable.

\Definitarg {:debug}

\Definitarg {:speed}

\Definitarg {:space}

\Definitarg {:safety}

\Definitarg {:compilation-speed}

To each optimize quality corresponds a reader.

\Defgeneric {debug} {optimize-qualities}

\Defgeneric {speed} {optimize-qualities}

\Defgeneric {space} {optimize-qualities}

\Defgeneric {safety} {optimize-qualities}

\Defgeneric {compilation-speed} {optimize-qualities}

An implementation typically does not only need its own optimize
qualities, but it may need to have its own mapping from combinations
of values of these optimize qualities to different behavior of the
compiler in different situations.  Furthermore, an implementation may
introduce new ASTs that also influence this behavior without any
\texttt{optimize} declarations.  For that reason, the following
object, also contained in the compilation context controls the details
of the compilation process.

\Defclass {compilation-options}

This class is a container for several options that control the
details of the compilation process.  Instances of this class are
immutable.  Implementations may specialize this class by creating a
subclass containing implementation-specific compilation options.

\Definitarg {:liveness-from-scope-p}

This initarg controls what the compiler does when it sees a
\texttt{scope-ast}, as defined in \refSec{sec-ast-scope}.  If the
value of this option is \emph{true}, then the compiler emits
an instruction that will artificially use the variable at the end of
the scope so that it will be kept alive for the duration of that scope
If the value of this option is \emph{false}, the compiler ignores the
\texttt{scope-ast} and compiles its \texttt{child-ast}, resulting in
the liveness of the variable being determined by the last time it is
used instead.
